---
title: "Fatala fishes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fatala fishes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, include=FALSE}
library(parallel)
library(ggraph)
library(tidygraph)
library(viridis)
library(tidyr)
library(gridExtra)
library(RColorBrewer)
```

This is a basic example detailing how to infer a network, using fishes counts from the Fatala River (Barans95 data from the `ade4` package).

## Fatala fishes dataset

The data is composed of 33 species abundances measures in 95 samples.

```{r fish_data , message=FALSE}
library(ade4)
library(tibble)
data(baran95)
Y = as.matrix(baran95$fau)
n = nrow(Y)
p = ncol(Y)
head(Y[,1:5])
str(Y)
```

The available covariates are the site and date of the samples. At each date and site, 4 samples were measured, except for kilometer 03 of January 93.
```{r}
X = as_tibble(baran95$plan)
str(X)
table(X$date, X$site)
```

## Network inference

EMtree infers a network from either a correlation matrix of a multivariate Gaussian, or an object created by PLNmodels from count data.
Therefore here we first create a  `PLNmodels` object:
```{r}
library(PLNmodels)
PLNfit<-PLN(Y ~ X$site)
```

And then run EMtree:

```{r output}
library(EMtree)
EMtreeFit<-EMtree(PLNfit,  maxIter = 20, plot=TRUE)
str(EMtreeFit)
```

To get a network from a fit of `EMtree()`, the probabilities stored in `edges_prob` can be thresholded. We propose the $2/p$ threshold as follows:
```{r}
probs<- EMtreeFit$edges_prob
net<-1*(probs>2/p)
```

To improve the robustness, the function `ResampleEMtree()` implements a stability selection of EMtree on S sub-samples. This function uses parallel computations with `mclapply()`.  The `Pmat` output gathers all the inferred edges probabilities for each sub-sample.
```{r, cache=TRUE}
ResampEmtreeFit<-ResampleEMtree(counts=Y, covar_matrix = X$site , S=5, maxIter=10,cond.tol=1e-8, cores=1)
str(ResampEmtreeFit)
```

Another way to specify the covariates matrix is to use the model.matrix() function as follows:
```{r}
built_covar_matrix=model.matrix(~X$site+X$date)
```
Then `built_covar_matrix` would be the `covar_matrix` parameter.

For the sake of the example we continue with the $site$ covariate only. Edges selection frequencies can be derived from the `Pmat` output with the function `freq_selec()`. This function simply summarizes the number of times an edge has a probability above the threshold `Pt`. A network can then be obtained by thresholding the frequencies, to keep for example edges that are selected in more than $80\%$ of sub-samples:
```{r}
freqs<-freq_selec(ResampEmtreeFit$Pmat,Pt=0.2)
resampNet<-1*(freqs>0.8)
```

The problem of course is that there is no rationale for the threshold on probabilities `Pt` ; the optimal threshold is unknown. A way to select the threshold is to compute the stability of the frequencies for any threshold, and select the desired stability. The function `StATS()` adapts the well-known penalty selection strategy StARS in the context of threshold selection.
```{r}
stab_selection=StATS(ResampEmtreeFit$Pmat, nlambda=50, stab.thresh=0.9,plot=TRUE)
```

We then keep the frequencies corresponding to the optimal lambda value, which is here at about $exp(-9.5)$. The optimal frequencies are stored in `stab_selection$freqs_opt`, the optimal threshold is `stab_selection$lambda_opt`.

The optimal frequencies still need to be thresholded in order to obtain a network. However, the task is very much simpler and understandable now: the higher the frequency, the more stable the edge along the resamples.

## Visualizations

The package `EMtree` has one general plotting function for network visualization: `draw_network()`. It builds from the `ggraph` and `tidygraph` packages, and provides with several interesting functionalities, among which

  - highlighting of important nodes ,
  - shading of edges,
  - defining groups of nodes and edges, with coloring possibilities,
  - using a previously stored layout.

### Basic usage

It takes an adjacency matrix as input and represents a network with edges widths proportional to the input weights. Several layouts are available (see the `ggraph` documentation). Highlighting of nodes possessing among the highest betweenness centrality measure is done with the parameter `btw_rank`. To disable this functionality, just set `btw_rank=1`.

`shade=TRUE` lowers the opacity of edges not linked to a highlighted node. This allows to better see the direct neighborhood of important nodes.

```{r, fig.height=4, fig.width=8, fig.fullwidth=FALSE, message=FALSE}
weighted_net=ToSym(stab_selection$freqs_opt)
net_50=ToSym(1*(stab_selection$freqs_opt>0.5))
net_95=ToSym(1*(stab_selection$freqs_opt>0.95))
g1<-draw_network(weighted_net,title="Weighted", pal_edges="dodgerblue3",layout="nicely",
                 shade = TRUE, btw_rank=3)$G
g2<-draw_network(net_50,title="Selected > 50%", pal_edges="dodgerblue3",layout="nicely",
                 shade = TRUE, btw_rank=3)$G
g3<-draw_network(net_95,title="Selected > 90%", pal_edges="dodgerblue3",layout="nicely",
                 shade = FALSE, btw_rank=3)$G
grid.arrange(g1, g2, g3, ncol=3)


```


### Storing a layout

To store a layout, we need to create it first, using the ggraph package for example. We only keep the columns corresponding to points coordinates.
```{r}
a_layout = create_layout(net_95, layout="nicely")[,1:2] %>% data.frame()
```

Then the layout is taken as the `stored_layout` parameter of `draw_network()`, as follows:
```{r,fig.height=4, fig.width=7}
args=list( pal_edges="dodgerblue3")
g1<-draw_network(net_50,title="Selected > 50%", pal_edges="dodgerblue3",
                 stored_layout = a_layout, btw_rank=3)$G
g2<-draw_network(net_95,title="Selected > 95%", pal_edges="dodgerblue3",
                 stored_layout = a_layout, btw_rank=3)$G
grid.arrange(g1, g2, ncol=2)
```


### Grouping of nodes and edges

It is possible to define groups of nodes with `node_groups` and edges with `edge_groups`, and color them accordingly using `pal_nodes` and `pal_edges`. For example :

```{r,fig.height=4, fig.width=4}
draw_network(net_95, title="Groups of nodes", pal_edges="gray70", 
             node_groups=sample(3,p, replace=TRUE),
             pal_nodes=brewer.pal(3,"Dark2"),layout="nicely")$G
```

```{r,fig.height=4, fig.width=4}
draw_network(net_95, title="Groups of edges", pal_nodes="gray70", 
             edge_groups=ToSym(sample(3,p*(p-1)/2,replace=TRUE)),
             pal_edges=brewer.pal(3,"Dark2"),layout="nicely", btw_rank=1)$G
```

